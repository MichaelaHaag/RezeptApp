\chapter{Clean Architecture}

Dieses Kapitel beschreibt die Architektur der entwickelten Software. Es wurde nach den in der Vorlesung erläuterten Clean-Architecture-Prinzipien gebaut. Clean Architecture ist ein Softwarearchitektur-Muster, welches zum Ziel hat, die Abhängigkeiten innerhalb einer Anwendung zu minimieren und die Wiederverwendbarkeit und Testbarkeit zu maximieren. Es besteht aus einer inneren Schicht von unabhängigen Entitäten, die von einer äußeren Schicht von Abhängigkeiten umgeben sind. Dies ermöglicht es Entwicklern, Anwendungen zu erstellen, die leicht zu testen, zu verstehen und zu warten sind und die flexibel sind, um schnell auf Änderungen reagieren zu können.

Im Folgenden werden die verwendeten Schichten genauer erläutert. Die Schicht \enquote{Abstraction Code} wurde in unserer Anwendung nicht verwendet, da für die in der Domäne behandelten Themengebiete kein Domänen übergreifendes Wissen notwendig war, welches Teil dieser Schicht hätte sein müssen. 
Außerdem haben wir die Adapters Code Schicht und die Application Code Schicht zusammengelegt. Der Code dieser Schichten befinden sich in der Schicht 1: Adapters Code.

\section{Schicht 3: Domain Code}
Die Domain Code Schicht umfasst die unabhängigen und wiederverwendbaren Geschäftslogik-Komponenten der Anwendung. Sie enthalten keine Abhängigkeiten von anderen Schichten und sind in der Regel unabhängig von der Benutzeroberfläche oder der Datenpersistenz.
In der Domain Code Schicht sind die beiden Aggregate und die enthaltenen Entitäten und Value Objects der Softwaredomäne. Für beide Aggregate wurde jeweils ein Repository erstellt, die sich auch in der Domain Code Schicht befinden. Die Repositories enthalten spezifische Methoden des Entity Managers, als Zwischenspeicher.  Außerdem befindet sich im Domain Code das Interface IEntityManager für die Dependecy Injection. Eine genauere Erläuterung befindet sich in Kapitel XX Dependency Injection. Alle Entitäten der Domäne implementieren das Interface IPersistierbar. Das IPersistierbar wird dazu genutzt, um sicherzustellen, dass die Entitäten eine UUID zum Speichern im Entity Manager haben.
Die Interfaces IEntityManager und IPersistierbar wurden beide neu erstellt.
Der Code in dieser Schicht verwendet nur Java-Standards, sodass er als Kern und langlebigste Softwareschicht keine Abhängigkeiten aufweist.

\section{Schicht 1: Adapters}
Dies sind die Schichten, die die Anwendungslogik mit der Benutzeroberfläche und der Datenpersistenz verbinden. Sie enthalten Adapter, die die Datenformate und Schnittstellen der Entitäten und Use Cases in diejenigen der Benutzeroberfläche und der Datenpersistenz übersetzen.
In unserer Anwendung befinden sich in der Adapters Schicht der Entity Manager. Der EntityManager implementiert das IEntityManager Interface. 
Darüber hinaus befindet sich in dieser Schicht die Informationen zu Daten Speicherung. 
- Ordner Datenpersistenz erstellt, beinhaltet alles für CSV Speicherung (CSV Funktionaliät wird möglichst nach außen in Schichten gelegt, dass schnell und einfach austauschbar ist)
    - Erstellung von Data Transfer Objekte, basierend auf den zugrundelegenden persistierbaren Entitäten, welche explizite Funktionalitäten zur Speicherung in CSV Dateien beinhalten. Deshalb implementieren alle Objekte ICSVPersistierbar
    - CSVReader und Writer dort rein verschoben, welche Objekte aus CSV Dateien lesen oder dort rein schreiben können
    - DataReader erstellt, dieser beinhaltet Funktionalität zum Laden der Daten aus den CSV Dateien in den EntityManager und zurück speichern (Funktionen aus Controller verschoben) 
    - DataReader beinhaltet Instanz des Entity Managers
    (hier noch ergänzen, was Herr Lindner gesagt hat, dass wir es mit im Text erwähnen sollen)
- Funktionalität wurde aus den GUI Klassen in sogenannte Funktionen Klassen ausgelagert und in Adapters Schicht gezogen als Zwischenstück zwischen GUI und Daten (Kathi vlt. noch Ergänzungen von dir)



\section{Schicht 0: Plugins}

% Frameworks and Drivers: Dies sind die äußersten Schichten der Anwendung, die die tatsächliche Ausführung auf spezifischen Plattformen, wie z.B. Web-Server, Datenbanken, ermöglichen.

- aufgeteilt in plugins und plugins-main
- beinhaltet eigentlich nur GUI und die Main Methode der APP 
- in RezeptApp Main wird DataReader Instanz erstellt und überall nach unten in Schichten weiter gegeben (durch UI), sodass man von überall auf EntityManager zugreifen kann 
- da man von inneren schichten nicht auf datareader Instanz in plugins mehr zugreifen kann wird er in Schichten nach unten durchgereicht Dependecy Rule

\section{Dependency Inversion}

Ausgangssituation: Hatten Repositories in Domain-Schicht, welche EntityManager von Adapters Schicht aufrufen (Dependecy Rule verletzt (Aufrufe von innen nach außen))

Deshalb Dependency Inversion und Injection: 
IEntityManager mit Methoden aus EntityManger erstellt in Domain Schicht und EntityManager implementiert das Interface
Repositories bekommen einen Entitymanager beim Aufruf übergeben, aber in Repository code hat dieser nur den Typ IEntityManager
Somit kann man auch den EnitiyManager in Domain Schicht "aufrufen"

Hierbei war wichtig, dass Entitys in Domain Schicht IPersistierbar implementieren, da dies in EntityManager vorausgesetzt wird. 
