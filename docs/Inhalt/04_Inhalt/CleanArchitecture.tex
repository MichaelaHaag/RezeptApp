\chapter{Clean Architecture}

Dieses Kapitel beschreibt die Architektur der entwickelten Software. Es wurde nach den in der Vorlesung erläuterten Clean-Architecture-Prinzipien gebaut. Clean Architecture ist ein Softwarearchitektur-Muster, welches zum Ziel hat, die Abhängigkeiten innerhalb einer Anwendung zu minimieren und die Wiederverwendbarkeit und Testbarkeit zu maximieren. Es besteht aus einer inneren Schicht von unabhängigen Entitäten, die von einer äußeren Schicht von Abhängigkeiten umgeben sind. Dies ermöglicht es Entwicklern, Anwendungen zu erstellen, die leicht zu testen, zu verstehen und zu warten sind und die flexibel sind, um schnell auf Änderungen reagieren zu können.

Im Folgenden werden die verwendeten Schichten genauer erläutert. Die Schicht \enquote{Abstraction Code} wurde in unserer Anwendung nicht verwendet, da für die in der Domäne behandelten Themengebiete kein Domänen übergreifendes Wissen notwendig war, welches Teil dieser Schicht hätte sein müssen. 
Außerdem haben wir die Adapters Code Schicht und die Application Code Schicht zusammengelegt. Der Code dieser Schichten befinden sich in der Schicht 1: Adapters Code.

\section{Schicht 3: Domain Code}
Die Domain Code Schicht umfasst die unabhängigen und wiederverwendbaren Geschäftslogik-Komponenten der Anwendung. Sie enthalten keine Abhängigkeiten von anderen Schichten und sind in der Regel unabhängig von der Benutzeroberfläche oder der Datenpersistenz.
In der Domain Code Schicht sind die beiden Aggregate und die enthaltenen Entitäten und Value Objects der Softwaredomäne. Für beide Aggregate wurde jeweils ein Repository erstellt, die sich auch in der Domain Code Schicht befinden. Die Repositories enthalten spezifische Methoden des Entity Managers, als Zwischenspeicher.  Außerdem befindet sich im Domain Code das Interface IEntityManager für die Dependecy Injection. Eine genauere Erläuterung befindet sich in Kapitel XX Dependency Injection. Alle Entitäten der Domäne implementieren das Interface IPersistierbar. Das IPersistierbar wird dazu genutzt, um sicherzustellen, dass die Entitäten eine UUID zum Speichern im Entity Manager haben.
Die Interfaces IEntityManager und IPersistierbar wurden beide neu erstellt.
Der Code in dieser Schicht verwendet nur Java-Standards, sodass er als Kern und langlebigste Softwareschicht keine Abhängigkeiten aufweist.

\section{Schicht 1: Adapters}
Die Adapters-Schicht in Clean Architecture stellt die Schnittstelle zwischen der Anwendung und externen Systemen dar. Sie ermöglicht die Kommunikation der Anwendung mit der Umgebung und besteht aus Adaptern, die dafür verantwortlich sind, die Daten von der Anwendung in eine Form zu konvertieren, die von den externen Systemen verarbeitet werden kann, und umgekehrt.
In unserer Anwendung befinden sich in der Adapters-Schicht der Entity Manager. Der EntityManager implementiert das IEntityManager Interface aus der Domain Code-Schicht. 
Darüber hinaus befindet sich in dieser Schicht die Konvertierung der Daten, die für die Speicherung notwendig ist.  In dieser Anwendung würde sich für eine Speicherung der Daten in CSV Dateien entschieden. Die CSV Funktionalitäten werden möglichst in die äußeren Schichten implementiert, um die Speicherung austauschbar zu gestalten.
Für die Konvertierung wurde der Ordner Datenpersistenz erstellt und das Interface ICSVPersistierbar implementiert. Das ICSVPersistierbar wird dazu genutzt, um sicherzustellen, dass die zugrundelegenden persistierbaren Entitäten eine UUID zum Speichern, sowie einen CSV Kopf und CSV Daten haben. Außerdem befinden sich im Ordner zu jeder persistierbaren Entitäte eine Klasse, die explizite Funktionalitäten zur Speicherung in CSV Dateien beinhalten. 
In der Adapters-Schicht befinden sich außerdem der CSVReader und CSVWriter. Der CSV Reader liest die Daten aus den CSV Dateien und packt sie in XXXX(EntityManager?). Der CSVWriter schreibt die Daten aus dem EntityManager in die CSV Dateien. Für das lesen und schreiben der Daten in und aus der CSV wurde zusätzlich der DataReader implementiert, der die Funktionalitäten zum Laden der Daten aus den CSV Dateien in den EntityManager und zurück beinhaltet.
Zusätzlich wurden, um die Code-Qualität und Wartbarkeit zu verbessern,  die Funktionen, die zuvor in den GUI-Klassen enthalten waren, in separate Funktionen-Klassen ausgelagert. Diese Funktionen-Klassen sind nun Teil der Adapters-Schicht, die als Vermittler zwischen der Benutzeroberfläche und den Daten fungiert.

    - DataReader beinhaltet Instanz des Entity Managers
    (hier noch ergänzen, was Herr Lindner gesagt hat, dass wir es mit im Text erwähnen sollen) (Verstehe nicht ganz was damit gemeint ist :/)




\section{Schicht 0: Plugins}
In der Clean Architecture sind Plugins optional einsetzbare Komponenten, die von der Kernanwendung getrennt sind und über Schnittstellen integriert werden können. Sie ermöglichen es, die Anwendung um zusätzliche Funktionen oder Integrationsmöglichkeiten zu erweitern, ohne die Kernanwendung selbst zu verändern. In unserer Anwendung haben wir die Plugins in Plugins und Plugins-Main aufgeteilt.
In den Plugins sind alle GUIs implementiert.
Die Plugins-Main Schicht beinhaltet die Main Methode der App. In der Main-Methode wird die DataReader Instanz erstellt und an die darunter liegenden Schichten weitergegeben, sodass man in allen Schichten auf den EntityManager zugreifen kann. Da man aus den unteren Schichten nicht auf die DataReader Instanz in der Plugins Schicht zugreifen kann, wird er in den Schichten nach unten durchgereicht-Dependency Rule.

\section{Dependency Inversion}
In der ursprünglichen Architektur haben Repositories innerhalb der Domain-Schicht den EntityManager aus der Adapters-Schicht aufgerufen. Dies verstieß gegen das Prinzip der Dependency Rule, das besagt, dass Abhängigkeiten immer von innen nach außen gerichtet sein sollten.

Um dieses Problem zu beheben, werden die Prinzipien der Dependency Inversion und Injection eingesetzt, um sicherzustellen, dass der EntityManager in der Domain-Schicht aufgerufen werden kann, ohne die Abhängigkeiten zwischen den Schichten zu verletzen.
Zu diesem Zweck wird eine Schnittstelle, IEntityManager, in der Domain-Schicht erstellt, um Methoden aus dem EntityManager aufzurufen. Der EntityManager selbst wird in die Adapters-Schicht umgelagert und implementiert das Interface. Um sicherzustellen, dass Repositories auf den EntityManager zugreifen können, wird beim Aufruf des Repositorys ein EntityManager-Objekt übergeben. Da der EntityManager jedoch nun als IEntityManager-Typ im Repository-Code deklariert ist, kann er auch in der Domain-Schicht aufgerufen werden. Hierbei war wichtig, dass Entitys in Domain Schicht IPersistierbar implementieren, da dies in EntityManager vorausgesetzt wird. 

Durch die Verwendung von Dependency Inversion und Injection wird die Abhängigkeit zwischen der Domain-Schicht und der Adapters-Schicht umgekehrt, sodass die Domain-Schicht unabhängig von der Adapters-Schicht bleibt. Dies verbessert die Flexibilität und Wartbarkeit der Anwendung und ermöglicht es, Komponenten einfach auszutauschen oder zu erweitern, ohne dass dies Auswirkungen auf andere Schichten hat.


