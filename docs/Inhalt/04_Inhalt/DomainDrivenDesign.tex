\chapter{Domain Driven Design}
In diesem Kapitel wird die Ubiquitous Language unseres Projektes analysiert. Außerdem werden die Entities \& Value Objects basierend auf der entwickelten Software modelliert und abschließend die verwendeten Repositories und Aggregates analysiert und erklärt.
\section{Ubiquitous Language}
\subsection{Sprache}
Ubiquitous Language  bedeutet, eine Sprache und die Begriffe so zu wählen, dass die Domänenexperten und die Entwickler minimalen Übersetzungsaufwand haben.  Aufgrund von einer deutschen Domäne und Anwendung haben wir deutsche Domänen Begriffe verwendet.
Die Dateinamen und Ordner der Javaklassen wurden so gewählt, dass sie den Domänenexperten und den nicht Entwicklern mit kurzen und aussagekräftigen Worten über die Funktionalität Aufschluss geben. !!! Folgendes wurde von Merlin inspiriert (umgeschrieben) übernommen und sollte hier erwähnt werden, wenn wir es gemacht haben: Handelt es sich um eine Entität oder ein Value Objekt, werden diese entsprechend benannt.
Da sich Ubiquitous Language  auf das gesamte Projekt bezieht, wurden auch die Tests in der Domain Sprache geschrieben und sollen für alle Leser verständlich sein. Der Test XXX, repräsentiert sehr gut die verwendete Ubiquitous Language. !!!
\subsection{Begriffsdefinition}
Die Anwendungsdomäne befasst sich mit der Verwaltung von Rezepten. Daher ist der erste zentrale Begriff der Domäne das \textbf{Rezept}. Ein Rezept setzt sich aus einer einer ID, einem Titel, einer Beschreibung, einer Menge von \textbf{Zutaten}, einer Menge von Rezept \textbf{Kategorien}, einer \textbf{Schwierigkeit} und optional einem \textbf{Bild} zusammen. Eine \textbf{Zutat} enthält Informationen, über den Namen der Zutat, in welcher \textbf{Menge} die Zutat in das Rezept gehört, sowie die dazugehörende \textbf{Einheit}. Die \textbf{Einheit} setzt sich aus einem Namen und einer Beschreibung zusammen.
Ein weiterer wichtiger Begriff in der Domäne sind die Rezept \textbf{Kategorien}. Sie enthalten einen Namen, eine Beschreibung und zusätzlich noch eine Kurzform des Namens für eine schönere Visualisierung in der Benutzeroberfläche.
Die \textbf{Schwierigkeit} eines Rezeptes kann in der Domäne \textbf{einfach}, \textbf{mittel} oder \textbf{schwer} sein. Das \textbf{Bild} enthält neben dem zugehörigen Rezept noch den \textbf{Pfad}, an dem ein Bild gespeichert ist.
\subsection{Entities \& Value Objects}
Im diesem Unterkapitel werden wir die Entities und Value Objects in unserer Rezepte Anwendung genauer analysieren. Entities sind Objekte, die eine Identität haben. Sie haben eine eindeutige ID und können von anderen Objekten referenziert werden. In unserer Anwendung haben wir verschiedene Entities. In Abbildung XX sind die Entities in blau dargestellt.
Rezept ist eine Entity, da es eine eindeutige Identität hat und veränderliche Eigenschaften hat. Ein Nutzer kann in der Anwendung die Rezepte nach dem Erstellen immer wieder bearbeiten. Die  Zutaten eines Rezepts setzen sich aus einer Menge, dem Namen der Zutat, einer ID und der ID des zugehörigen Rezepts zusammen. Außer den beiden IDs können auch die Eigenschaften von Zutaten verändert werden. Daher ist auch die Zutat ein Entity. Das Bild, das zu einem Rezept gehört wird in unserer Anwendung auch als Entity betrachtet, da es eindeutig identifizierbar ist, durch eine eindeutige ID, mit dem Rezept verknüpft werden kann und über die Eigenschaft Pfad verfügt. Der Pfad des Bildes kann verändert werden. Kategorie ist das vierte Entity der Domäne. Rezepte werden verschiedenen Kategorien zugeordnet und die Nutzer können sich eine Liste mit allen Rezepten für eine Kategorie anschauen, dafür ist es notwendig, dass Kategorie eine eindeutige ID hat und referenzierbar ist. 
Value Objects hingegen haben keine Identität. Sie werden lediglich durch ihre Eigenschaften definiert und können nicht von anderen Objekten referenziert werden. In unserer Anwendung gibt es das Value Object: Menge. Eine Zutaten-Menge hat keine eindeutige Identität, sondern beschreibt einfach den Umfang oder die Menge einer bestimmten Zutat, die in einem Rezept verwendet wird. Eine Zutaten-Menge hat keine eigenen Eigenschaften oder Verhaltensweisen und kann nicht auf andere Objekte referenzieren. Eine Menge setzt sich aus der Menge und einer Einheit zusammen. 

In der Domäne gibt es zusätzlich die Enumeration Schwierigkeit und Einheit. Enumeration können eine Sammlung von Value Objecte sein, wenn in den Enum-Instanzen kein veränderbarer Zustand hinterlegt ist. Die Enumeration Schwierigkeit kann nur die Werte: Einfach, Normal und Schwer annehmen und diese Instanzen haben keine Eigenschaften und sind nicht veränderbar. Darum handelt es sich bei dem Enum Schwierigkeit um ein Value Object. Bei der Enumeration Einheit ist das ähnlich. Einheit hat keine eindeutige Identität und beschreibt lediglich die Art der Messung, die verwendet wird, um die Menge einer Zutat zu beschreiben, z.B. Gramm oder Teelöffel. Es hat allerdings die Eigenschaften Name und Beschreibung. Daher wird die Einheit, die bei der Angabe der Menge einer Zutat verwendet wird, als Enity betrachtet.

Wir haben uns dazu entschieden die ID bei allen Entities mit Surrogatschlüsseln umzusetzen. Dafür haben wir allen Enity Elemente in unserer Domäne eine UUID. Universally Unique Identifier, kurz UUID, ist ein Standard für Identifikationsnummern. Vorteil von UUIDs sind, dass sie jederzeit generierbar sind und das sie anwendungsübergreifend eindeutig sind. Außerdem ist hier die Verteilung der IDs einfacher, da eine UUID generiert werden kann ohne, dass sie mit den bereits vorhandenen UUIDs verglichen werden muss, da  es sehr unwahrscheinlich, dass versehentlich doppelte UUIDs generiert werden. Auch die Nachteile, wie: Nicht sprechend, keine Bedeutung in der Domäne und eventuelle Engpässe bei Generierung in
Hochlastsystemen sind in unserer Anwendung nicht von Bedeutung, da der Schlüssel einfach aus der CSV ausgelesen werden kann. ??Mehr erläuterung??

\subsection{Aggregates}
Aggregate gruppieren die Entities und Value Objects zu gemeinsam verwalteten Einheiten. Die Verwendung von Aggregaten ermöglicht das Entkoppeln der Objektbeziehungen, Bilden natürlicher Transaktionsgrenzen und kontinuierliche Übereinstimmung mit den Domänenregeln. 
Da alle Klassen im Packet XXX Eigenschaften eines Rezeptes abbilden, werden diese zu einem Aggregate zusammengefasst. Dazu gehören, Rezept, Kategorie, Bild und Schwierigkeit. Die Root Entität ist dabei das Rezept selbst. Im zweiten Aggregat verhält es sich ähnlich. Auch hier bilden alle Klassen direkt oder indirekt Eigenschaften der Zutat ab, daher werden auch diese, also Menge und Einheit zu einem Aggregate zusammengefasst. Die Root Entity ist hier die Zutat.

\subsection{Repositories}
Für den Zugriff auf den persistenten Speicher werden zwei Repositories gemäß dem Grundsatz „Ein Repository pro Aggregate“ definiert: Das XXRepository erlaubt den Zugriff auf das Rezept, also die Root Entity des entsprechenden Aggregates. Analog hierzu
ermöglicht das XXRepository Zugriff auf die Zutat als Root Entity des zugehörigen Aggregates.
