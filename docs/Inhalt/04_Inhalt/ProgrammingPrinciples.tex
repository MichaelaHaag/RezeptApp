\chapter{Programming Principles}
Programming principles (Programmierprinzipien) sind Grundsätze, die beim Entwurf, der Entwicklung und dem Testen von Software angewendet werden können. Sie sind eine Verallgemeinerung wiederkehrender Erkenntnisse in der Softwareentwicklung und liefern Entwicklern Richtlinien für einen bestimmten Programmierstil.
Im Allgemeinen zielen sie darauf ab, die Qualität und Robustheit von Software zu verbessern. Im folgenden Abschnitt werden drei Programming principles vorgestellt und deren Anwendung in unserem Projekt analysiert. 
\section{SOLID}
Die SOLID-Prinzipien sind ein Konzept für objektorientierte Programmierung, das fünf Grundsätze für die Entwicklung von hochwertigem und wartbarem Code definiert. Indem man diese Prinzipien befolgt, kann man sicherstellen, dass der Code besser strukturiert und leichter zu erweitern ist, und dass er weniger fehleranfällig ist und besser gewartet werden kann. Jeder Buchstabe in SOLID steht für einen dieser Grundsätze:
\subsection{Single Responsibility Principle (SRP)}
Das Single Responsibility Principle (SRP) besagt, dass ein einzelnes Objekt oder eine Klasse nur für eine einzige Aufgabe oder Verantwortlichkeit zuständig sein  sollte.
In unserer Anwendung ist beispielsweise eine Klasse, die dieses Prinzip strikt einhält: FunktionenZufallsGenerator. Diese Klasse hat lediglich die Aufgabe, aus einer Liste von Rezepten ein \glqq zufälliges\grqq{} Rezept auszuwählen. 
Ein Negativbeispiel für eine Klasse, die das Single Responsibility Principle nicht einhält, ist unser EntityManager. Unser EntityManager wird verwendet, um eine Verbindung zwischen den Objekten der Anwendung und der zugrunde liegenden Datenbank herzustellen. Mit dem EntityManager wollten wir die Verwaltung von Objekten und deren Zuständen vereinfachen. Das bedeutet allerdings, dass der EntityManager mehrere Aufgaben (Verantwortungen) hat und somit das Prinzip verletzt. 
Andere Positivbeispiele für die Einhaltung des Single Responsibility Principle sind beispielsweise die Klassen FunktionenRezeptBearbeiten, FunktionenNeuesRezept, ButtonRenderer und FunktionenListenÜbersicht. Die Klasse FunktionenListenÜbersicht ist beispielsweise nur dafür verantwortlich alle Rezepte zu einer angeklickten Kategorie zurückzugeben. 
\subsection{Open-Closed-Prinzip}
Das Open-Closed-Prinzip besagt, dass Software-Entitäten offen für Erweiterungen sein sollte, aber geschlossen bezüglich Veränderungen. Das bedeutet, dass bestehender Code nicht mehr geändert werden sollte, sondern neue Funktionalitäten hinzugefügt werden. Dadurch soll sichergestellt werden, dass die bestehende Funktionalität nicht beeinträchtigt wird und dass die Erweiterung der Software einfacher und sicherer ist. Die Klasse EntityManager, die auch das Single Responsibility Principle verletzt, ist auch ein Negativbeispiel für das Open-Closed-Principle. Da diese Klasse jeweils alle Use-Cases implementiert, die die Entitytäten betreffen, muss bei geänderten oder neuen Anforderungen diese bestehende Klassen verändert werden.
Ein Beispiele für die Einhaltung des Open-Closed-Principle sind die GUI Funktionen in der Adapterschicht.
Hier existiert für jeden einzelnen Use-Case eine separate Klasse, sodass bei
neuen Anforderungen lediglich eine neue Klasse implementiert werden müsste
und damit der bestehende Code nur erweitert. Die einzige Änderung an bestehendem Code würde in den GUI Klassen stattfinden, da dort neue Events bzw. die zugehörigen Callbacks registriert werden.

\subsection{Liskov substitution principle (LSP)}
Das Liskov substitution principle besagt, dass es möglich sein muss, Instanzen von Objekten durch ihre Subtypen zu ersetzen, ohne die Korrektheit des Programms zu beeinträchtigen. Kurz gesagt, soll die Ableitungsklasse alle Eigenschaften und Methoden der Basisklasse beibehalten und diese nicht modifizieren oder verletzen. Problematisch kann es sein, wenn Subtypen eine Spezialisierung des Supertypen sind. Ein Beispiel einer Verletzung der Regel: Quadrat wird als Subtyp eines Rechteckes implementiert. Subtypen sind eine Spezialisierung des Supertyps.
In dem vorliegenden Projekt ist keine Vererbungsbeziehung vorhanden, die auf das Liskov Substitution Principle untersucht werden kann, da in keinem Fall
von einer eigenen konkreten Klasse geerbt wird, sondern nur von abstrakten Klassen. Es könnte beispielsweise die Klassen Startseite auf das
Liskov Substitution Principle untersucht werden, jedoch ist es hier trivial, dass das Prinzip eingehalten wird, da die Subtypen keine Funktionalität des Supertypen überschreiben.

\subsection{Interface-Segregation-Principle (ISP)}
Das Interface-Segregation-Prinzip besagt, dass mehrere spezifische Interfaces besser sind als ein Allround-Interface.
Die Schnittstellen sollten also schlank und spezifisch sein, damit Clients nur das implementieren müssen, was sie tatsächlich brauchen, anstatt gezwungen zu sein, unnötige Methoden zu implementieren, um Abhängigkeiten und Kopplung zwischen Modulen oder Klassen zu reduzieren und die Wartbarkeit und Flexibilität des Codes zu verbessern.

Gute Beispiele für die Einhaltung des Interface-Segregation-Principles finden sich in den Klassen ICSVPersistierbar und IPersistierbar wieder.
Beide Interfaces haben jeweils nur eine oder wenige Methode, die nur einen einzigen Nutzen definieren. Das Interface ICSVPersistierbar enthält Methoden die zur Speicherung der Objekte notwendig sind und in den Objekten implementiert werden müssen. IPersistierbar wird verwendet, um die UUID zu lesen, die im EntityManager benötigt wird.  Für dieses Vorhaben definiert dieses Interface die Methode bekommeUUID.

Ein Negativbeispiel für die Einhaltung des Interface-Segregation-Principles findet sich in dem Interfaces IEntityManager. Diese kombiniert jeweils den schreibenden Zugriff, das Löschen und das Suchen von Objekten in einem einzigen Interface. Dieses Interface könnte aufgeteilt werden auf jeweils ein Interface für den schreibenden Zugriff, eins für das Löschen von Objekten und ein weiteres Interface für das Suchen nach Objekten. Dadurch bräuchte ein Klient, welcher nur schreibende Zugriffe benötigt, keine Abhängigkeiten auf ein Interface, welches auch löschenden Zugriff erlaubt. Durch eine solche Aufteilung könnte eine Zugriffsverwaltung wesentlich leichter implementiert werden.
\subsection{Dependency inversion principle (DIP)}
Das Dependency-Inversion-Principle besagt, dass Klassen höherer Ebenen nicht von Klassen niederer Ebenen abhängig sein sollen, sondern beide
von Interfaces. Durch die Verwendung von abstrakten Schnittstellen oder Interfaces können Änderungen an einer konkreten Implementierung vorgenommen werden, ohne dass dies Auswirkungen auf die anderen Module oder Klassen hat, die von dieser Implementierung abhängen. Das Dependency-Inversion-Principle trägt somit zur Flexibilität, Erweiterbarkeit und Wartbarkeit von Software bei.
Ein Beispiel für das Dependency-Inversion-Principle ist zum beispiel unser Entity Manager. Hier wurde die allgemeine Schnittstelle IEntityManager definiert, welches die Methoden des EntityManager beinhaltet. Der EntityManager selbst wird in die Adapters-Schicht implementiert. Dadurch
haben die Entitäten im Domain Code keine Abhängigkeit auf die
konkreten Implementierungen, sondern erhält diese lediglich durch Aufrufe der Methoden.

\section{GRASP}
GRASP steht für General Responsibility Assignment Software Patterns/Prinziples und ist ein Muster oder Prinzipg, die sich mit der Zuweisung von Verantwortlichkeiten an Objekte befasst. GRASP stellt 9 Lösungsprinzipien für die Softwareentwicklung vor. Zum Grundkonzept gehören zwei der Lösungsprinzipien: Low Coupling und High Cohesion. Beide gehören mit zuden wichtigsten Prinzipen für das GRASP-Programmierprinzip. Daher werden beide im folgenden anhand unserer Anwendung erläutert und analysiert.

\subsection{Low Coupling}
Low Coupling ist eines der Muster, das sich auf die Reduzierung der Abhängigkeiten einer Klasse von ihrer Umgebung konzentriert. Das Ziel ist es, die Verbindungen zwischen den verschiedenen Komponenten im System zu minimieren, um eine höhere Flexibilität, leichtere Anpassbarkeit, gute Testbarkeit, erhöhte Wiederverwendbarkeit und Erweiterbarkeit zu erreichen. Außerdem je loser die Kopplung, desto leichter ist die Austauschbarkeit der Funktionalität.
Auch die in \autoref{CA} gemachten Änderungen haben darauf abgezielt die Kopplung zu reduzieren. Denn das Ziel von Clean Architecture ist, die Abhängigkeiten zwischen verschiedenen Schichten eines Systems zu minimieren. Das bedeutet, dass jede Schicht in der Architektur so gestaltet wurde, dass sie nur von den Schichten darunter abhängt und keine Kenntnis über die Schichten darüber hat.
Da das Projekt der Clean Architecture entspricht, gilt allgemein, dass die inneren Schichten eine geringe Kopplung zu den äußeren Klassen haben sollten. 
Somit sollten die Klassen im Domain Code generell eine geringere Kopplung als die Klassen in den Plugins haben. Allerdings können die Klassen in den untern Schichten auch innerhalb einer Schicht viele Abhängigkeiten haben. So haben die Klasse Bild und Schwierigkeit eine geringe Kopplung, wobei Rezept eine hohe Kopplung hat.  
In der Klasse Rezept koppeln sich die Abhängigkeiten mit den Klassen Kategorie, Zutat, Bild und Schwierigkeit. Für eine zusätzliche stärkere Kopplung sorgt die Instanziierung der Arraylisten
von Kategorie und Zutat im Konstruktor.
Auf der anderen Seite sind neben einigen Domain-Code Klassen unsere GUI-Klassen Beispiele für Klassen mit schwacher Kopplung. Diese Klassen besitzen jeweils nur wenige Abhängigkeit (Kopplung) zueinander. 
Ein weiteres Beispiel für geringe Kopplung ist die Klasse FunktionenStartseite. Die Klasse weist eine Abhängigkeit mit
der Klasse NeueKategorie auf.

\subsection{High Cohesion}
High Cohesion  ist ein Maß für den inneren Zusammenhalt einer Klasse, zeigt also wie eng
die Methoden und Attribute einer Klasse zusammenarbeiten. Mit anderen Worten, eine Klasse sollte eng miteinander verbundene und verwandte Funktionalitäten enthalten, um eine hohe Kohäsion zu erreichen. 
Die Klasse EntityManager der GUI Funktionen zeugt von geringerer Kohäsion, da hier mehrere Use-Cases in einer Klasse implementiert werden. Der EntityManager dient der Datenhaltung und hat die Aufgaben, Objekte zu speichern/löschen und zu finden. Eine
verbesserte Implementierung bietet sich folgendermaßen an, indem die einzelnen Operationen separat in Klassen
eines Moduls implementiert werden.

FunktionenZufallsGenerator zeigt von hoher Kohäsion, da diese lediglich einen Use-Case behandelt. Diese Klasse hat lediglich die Aufgabe, aus einer Liste von Rezepten
ein „zufälliges“ Rezept auszuwählen. Dafür besitzt diese Klasse
lediglich die Methode zufälligeRezeptUUID, die diese Logik implementiert.

\section{DRY}
Das DRY-Prinzip steht für "Don't Repeat Yourself" und besagt, dass man eine bestimmte Information oder Funktionalität in einer Software nur an einer Stelle definieren sollte, um Redundanz zu vermeiden. Jeder Wissensaspekt darf nur eine einzige,
unzweideutig verbindliche Repräsentation in einem
System besitzen.
Das bedeutet, dass man sich bemüht, Code-Duplikationen zu vermeiden und stattdessen wiederverwendbare Komponenten und Funktionen zu schaffen, die an verschiedenen Stellen in der Software verwendet werden können. Auf diese Weise wird der Code einfacher zu warten, zu testen und zu erweitern.

Ein Negativbeispiel für das Nichteinhalten des DRY-Prinzips ist in der Implementierung
der GUI Klassen. Der generelle Aufbau der GUI wurde in jeder Klasse implementiert und lediglich der Hauptinhalt ausgetauscht. Das führt zu einer Dopplung der Informationen. Würden die Entwickler entscheiden beispielsweise den Footer der GUIs ändern zu wollen und beispielsweise den Button Text Startseite durch HomePage ersetzen zu wollen, müsste diese kleine Änderung in 3 Klassen geändert werden. Diese Verletzung des DRY-Prinzips wurde aus Unerfahrenheit der Entwickler begangen und soll in Zukunft vermieden werden. 
\todo{Was sind weitere Dopplungen oder eher auslagerungen?}

Ein Beispiel für die Einhaltung des DRY-Prinzips ist in der Verifizierung der Parameter
eines Callbacks zu sehen. Hier wird zentral in jeder Callback-Klasse durch die Metho28
Programmentwurf Programming Principles
de getRequiredParameters definiert, welche Parameter benötigt werden. Das CLI
Plugin nutzt diese Informationen, um die übergebenen Parameter in der Methode ensureRequiredParameters auf Vollständigkeit für den entsprechenden Callback zu
prüfen sowie um die Benutzerhilfe in constructOptions zu generieren.

