\chapter{Programming Principles}
Programming Principles (Programmierprinzipien) sind Grundsätze, die beim Entwurf, der Entwicklung und dem Testen von Software angewendet werden können. Sie sind eine Verallgemeinerung wiederkehrender Erkenntnisse in der Softwareentwicklung und liefern Entwicklern Richtlinien für einen bestimmten Programmierstil.
Im Allgemeinen zielen sie darauf ab, die Qualität und Robustheit von Software zu verbessern. Im folgenden Abschnitt werden drei Programming Principles vorgestellt und deren Anwendung in unserem Projekt analysiert. 

\section{SOLID}
Die SOLID-Prinzipien sind ein Konzept für objektorientierte Programmierung, das fünf Grundsätze für die Entwicklung von hochwertigem und wartbarem Code definiert. Indem man diese Prinzipien befolgt, kann man sicherstellen, dass der Code besser strukturiert und leichter zu erweitern ist, und dass er weniger fehleranfällig ist und besser gewartet werden kann. Jeder Buchstabe in SOLID steht für einen dieser Grundsätze:

\subsection{Single Responsibility Principle (SRP)}
Das Single Responsibility Principle (SRP) besagt, dass ein einzelnes Objekt oder eine Klasse nur für eine einzige Aufgabe oder Verantwortlichkeit zuständig sein  sollte.
In unserer Anwendung ist beispielsweise eine Klasse, die dieses Prinzip strikt einhält: \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/FunktionenZufallsGenerator.java}{\code{FunktionenZufallsGenerator}}. Diese Klasse hat lediglich die Aufgabe, aus einer Liste von Rezepten ein \glqq zufälliges\grqq{} Rezept auszuwählen. 
Ein Negativbeispiel für eine Klasse, die das Single Responsibility Principle nicht einhält, ist der \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/Datenpersistenz/EntityManager.java}{\code{EntityManager}}. Unser \code{EntityManager} wird verwendet, um eine Verbindung zwischen den Objekten der Anwendung und der zugrunde liegenden Datenbank herzustellen. Mit dem \code{EntityManager} wollten wir die Verwaltung von Objekten und deren Zuständen vereinfachen. Das bedeutet allerdings, dass der \code{EntityManager} mehrere Aufgaben (Verantwortungen), wie das Speichern, Finden, Löschen, etc. von Objekten, hat und somit das Prinzip verletzt. 
Andere Positivbeispiele für die Einhaltung des Single Responsibility Principle sind beispielsweise die Klassen \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/FunktionenRezeptBearbeiten.java}{\code{FunktionenRezeptBearbeiten}}, \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/FunktionenNeuesRezept.java}{\code{FunktionenNeuesRezept}}, \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/ButtonRenderer.java}{\code{ButtonRenderer}} und \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/FunktionenListenÜbersicht.java}{\code{Funktionen ListenÜbersicht}}. Die Klasse \code{FunktionenListenÜbersicht} ist beispielsweise nur dafür verantwortlich alle Rezepte zu einer ausgewählten Kategorie zurückzugeben. 

\subsection{Open-Closed-Prinzip}
Das Open-Closed-Prinzip besagt, dass Software-Entitäten offen für Erweiterungen sein sollten, aber geschlossen bezüglich Veränderungen. Das bedeutet, dass bestehender Code nicht mehr geändert werden sollte, sondern neue Funktionalitäten hinzugefügt werden. Dadurch soll sichergestellt werden, dass die bestehende Funktionalität nicht beeinträchtigt wird und dass die Erweiterung der Software einfacher und sicherer ist. Die Klasse \code{EntityManager}, die auch das Single Responsibility Principle verletzt, ist auch ein Negativbeispiel für das Open-Closed-Principle. Da diese Klasse jeweils alle Use-Cases implementiert, die die Entitytäten betreffen, muss bei geänderten oder neuen Anforderungen diese bestehende Klassen verändert werden.
Ein Beispiel für die Einhaltung des Open-Closed-Principle sind die \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen}{\code{GUI Funktionen}} in der Adapterschicht.
Hier existiert für jeden einzelnen Use-Case eine separate Klasse, sodass bei neuen Anforderungen lediglich eine neue Klasse implementiert werden müsste und damit der bestehende Code nur erweitert. Die einzige Änderung an bestehendem Code würde in den GUI Klassen stattfinden, da dort neue Events bzw. die zugehörigen Callbacks registriert werden.

\subsection{Liskov Substitution Principle (LSP)}
Das Liskov Substitution Principle besagt, dass es möglich sein muss, Instanzen von Objekten durch ihre Subtypen zu ersetzen, ohne die Korrektheit des Programms zu beeinträchtigen. Kurz gesagt, soll die Ableitungsklasse alle Eigenschaften und Methoden der Basisklasse beibehalten und diese nicht modifizieren oder verletzen. Problematisch kann es sein, wenn Subtypen eine Spezialisierung des Supertypen sind. Ein Beispiel einer Verletzung der Regel: Quadrat wird als Subtyp eines Rechteckes implementiert. Subtypen sind eine Spezialisierung des Supertyps.
In dem vorliegenden Projekt ist keine Vererbungsbeziehung vorhanden, die auf das Liskov Substitution Principle untersucht werden kann, da in keinem Fall von einer eigenen konkreten Klasse geerbt wird, sondern nur von abstrakten Klassen. Beispielsweise bei der Klasse \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/0-Plugins/src/main/java/de/rezeptapp/plugins/gui/Startseite.java}{\code{GUI Startseite}}, ist die Untersuchung auf das Liskov Substitution Principle trivial, da die Subtypen keine Funktionalität des Supertypen überschreiben.

\subsection{Interface-Segregation-Principle (ISP)}
Das Interface-Segregation-Principle besagt, dass mehrere spezifische Interfaces besser sind, als ein Allround-Interface. Die Schnittstellen sollten also schlank und spezifisch sein, damit Clients nur das implementieren müssen, was sie tatsächlich brauchen, anstatt gezwungen zu sein, unnötige Methoden zu implementieren, um Abhängigkeiten und Kopplung zwischen Modulen oder Klassen zu reduzieren und die Wartbarkeit und Flexibilität des Codes zu verbessern.

Gute Beispiele für die Einhaltung des Interface-Segregation-Principles finden sich in den Klassen \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/Datenpersistenz/ICSVPersistierbar.java}{\code{ICSVPersistierbar}} und \href{https://github.com/MichaelaHaag/RezeptApp/tree/main/3-Domain-Code/src/main/java/de/rezeptapp/domain/IPersistierbar.java}{\code{IPersistierbar}} wieder.
Beide Interfaces haben jeweils nur eine oder wenige Methode, die nur einen einzigen Nutzen definieren. Das Interface \code{ICSVPersistierbar} enthält Methoden die zur Speicherung der Objekte notwendig sind und in den Objekten implementiert werden müssen. \code{IPersistierbar} wird verwendet, um die UUID zu lesen, die im \code{EntityManager} benötigt wird. Für dieses Vorhaben definiert dieses Interface die Methode \code{bekommeUUID}.

Ein Negativbeispiel für die Einhaltung des Interface-Segregation-Principles findet sich in dem Interfaces \code{IEntityManager}. Diese kombiniert jeweils den schreibenden Zugriff, das Löschen und das Suchen von Objekten in einem einzigen Interface. Dieses Interface könnte aufgeteilt werden auf jeweils ein Interface für den schreibenden Zugriff, eins für das Löschen von Objekten und ein weiteres Interface für das Suchen nach Objekten. Dadurch bräuchte ein Client, welcher nur schreibende Zugriffe benötigt, keine Abhängigkeiten auf ein Interface, welches auch löschenden Zugriff erlaubt. Durch eine solche Aufteilung könnte eine Zugriffsverwaltung wesentlich leichter implementiert werden.

\subsection{Dependency-Inversion-Principle (DIP)}
Das Dependency-Inversion-Principle besagt, dass Klassen höherer Ebenen nicht von Klassen niederer Ebenen abhängig sein sollen, sondern beide von Interfaces. Durch die Verwendung von abstrakten Schnittstellen oder Interfaces können Änderungen an einer konkreten Implementierung vorgenommen werden, ohne dass dies Auswirkungen auf die anderen Module oder Klassen hat, die von dieser Implementierung abhängen. Das Dependency-Inversion-Principle trägt somit zur Flexibilität, Erweiterbarkeit und Wartbarkeit von Software bei.
Ein Beispiel für das Dependency-Inversion-Principle ist unser \code{EntityManager}. Hier wurde die allgemeine Schnittstelle \code{IEntityManager} definiert, welches die Methoden des \code{EntityManager} beinhaltet. Der \code{EntityManager} selbst wird in der Adapters-Schicht implementiert. Dadurch haben die Abstraktionen im Domain Code keine Abhängigkeit auf die detaillierten Implementierungen in der Adapters-Schicht, sondern sie erhalten die Informationen lediglich durch Aufrufe der Methoden des Interfaces. Somit wird der Methode im Domain Code die konkrete Instanz des EntityManagers durch Eingabeparameter gegeben (Eine genauere Erläuterung der Umsetzung ist in \autoref{DI}). Ein negatives Beispiel gibt es hier nicht, da die Rezept-Anwendung in \autoref{CA} den Clean Code Vorgaben entsprechend geändert wurde und dadurch keine Klassen niedriger Ebene abhängig von Klassen höherer Ebene mehr sind.

\section{GRASP}
GRASP steht für General Responsibility Assignment Software Patterns/Principle und ist ein Muster oder Prinzip, dass sich mit der Zuweisung von Verantwortlichkeiten an Objekte befasst. GRASP stellt neun Lösungsprinzipien für die Softwareentwicklung vor. Zum Grundkonzept gehören zwei der Lösungsprinzipien: Low Coupling und High Cohesion. Beide gehören mit zu den wichtigsten Prinzipen für das GRASP-Programmierprinzip. Daher werden beide im folgenden anhand unserer Anwendung erläutert und analysiert.

\subsection{Low Coupling}
Low Coupling ist eines der Muster, das sich auf die Reduzierung der Abhängigkeiten einer Klasse von ihrer Umgebung konzentriert. Das Ziel ist es, die Verbindungen zwischen den verschiedenen Komponenten im System zu minimieren, um eine höhere Flexibilität, leichtere Anpassbarkeit, gute Testbarkeit, erhöhte Wiederverwendbarkeit und Erweiterbarkeit zu erreichen. Außerdem je loser die Kopplung ist, desto leichter ist die Austauschbarkeit der Funktionalität.
Auch die in Kapitel \nameref{CA} gemachten Änderungen haben darauf abgezielt die Kopplung zu reduzieren. Denn das Ziel von Clean Architecture ist, die Abhängigkeiten zwischen verschiedenen Schichten eines Systems zu minimieren. Das bedeutet, dass jede Schicht in der Architektur so gestaltet wurde, dass sie nur von den Schichten darunter abhängt und keine Kenntnis über die Schichten darüber hat. Da das Projekt der Clean Architecture entspricht, gilt allgemein, dass die inneren Schichten keine Kopplungen zu den äußeren Schichten haben. 
Somit sollten die Klassen, in der untersten Schicht, im Domain Code, generell eine geringere Kopplung als die Klassen in den Plugins haben. Allerdings können die Klassen in den untern Schichten auch innerhalb einer Schicht viele Abhängigkeiten haben. So haben die Klasse \code{Bild} und \code{Schwierigkeit} der Domain Code Schicht eine geringe Kopplung, wobei \code{Rezept} eine hohe Kopplung hat.  
In der Klasse \code{Rezept} koppeln sich die Abhängigkeiten mit den Klassen \code{Kategorie}, \code{Zutat}, \code{Bild} und \code{Schwierigkeit}. Für eine zusätzliche stärkere Kopplung sorgt die Instanziierung der Arraylisten von \code{Kategorie} und \code{Zutat} im Konstruktor.
Auf der anderen Seite sind neben einigen Domain-Code Klassen unsere \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/0-Plugins/src/main/java/de/rezeptapp/plugins/gui}{\code{GUI-Klassen}} Beispiele für Klassen mit schwacher Kopplung. Diese Klassen besitzen jeweils nur wenige Abhängigkeit (Kopplung) zueinander. 
Ein weiteres Beispiel für geringe Kopplung ist die Klasse \code{FunktionenStartseite}. Die Klasse weist eine Abhängigkeit mit der Klasse \code{NeueKategorie} auf.

\subsection{High Cohesion}
High Cohesion  ist ein Maß für den inneren Zusammenhalt einer Klasse, zeigt wie eng die Methoden und Attribute einer Klasse zusammenarbeiten. Mit anderen Worten, eine Klasse sollte eng miteinander verbundene und verwandte Funktionalitäten enthalten, um eine hohe Kohäsion zu erreichen. 
Die Klasse \code{EntityManager} der Adapters-Schicht zeugt von geringerer Kohäsion, da hier mehrere Use-Cases in einer Klasse implementiert werden. Der \code{EntityManager} dient der Datenhaltung und hat die Aufgaben, Objekte zu speichern/löschen und zu finden. Eine verbesserte Implementierung bietet sich an, indem die einzelnen Operationen separat in Klassen eines Moduls implementiert werden.

\href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/GUIFunktionen/FunktionenZufallsGenerator.java}{\code{FunktionenZufallsGenerator}} zeigt von hoher Kohäsion, da diese lediglich einen Use-Case behandelt. Diese Klasse hat lediglich die Aufgabe, aus einer Liste von Rezepten ein „zufälliges“ Rezept auszuwählen. Dafür besitzt diese Klasse lediglich die Methode \code{zufälligeRezeptUUID}, die diese Logik implementiert. Auch die Klassen \code{CSVReader} und \code{CSVWriter} zeigen von hoher Kohäsion. Beide Klassen haben drei Methoden die für das Lesen/Schreiben von den CSV Daten notwendig sind. Einen Konstruktor, eine \code{checkFile} und die \code{Lese} bzw. \code{Schreibe} Funktion. 

\section{DRY}\label{DRY}
Das DRY-Prinzip steht für \glqq Don't Repeat Yourself \grqq{} und besagt, dass man eine bestimmte Information oder Funktionalität in einer Software nur an einer Stelle definieren sollte, um Redundanz zu vermeiden. Jeder Wissensaspekt darf nur eine einzige, unzweideutig verbindliche Repräsentation in einem
System besitzen. Das bedeutet, dass man sich bemüht, Code-Duplikationen zu vermeiden und stattdessen wiederverwendbare Komponenten und Funktionen zu schaffen, die an verschiedenen Stellen in der Software verwendet werden können. Auf diese Weise wird der Code einfacher zu warten, zu testen und zu erweitern.
Ein Beispiel für die Einhaltung ist die Methode \code{findeRezepteZuKategorie} in dem \code{RezeptRepository}. Diese Klasse wurde zentral implementiert und definiert und wird von verschiedenen Klassen aufgerufen, um alle Rezepte zu einer Kategorie zu finden. Durch die zentrale Implementierung wird hier Code-Duplikationen vermieden. 

Ein Negativbeispiel für das Nichteinhalten des DRY-Prinzips ist in der Implementierung der \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/0-Plugins/src/main/java/de/rezeptapp/plugins/gui}{\code{GUI-Klassen}}. Alle GUI's haben denselben Footer. Im Footer befinden sich die drei Buttons: \emph{Zufallsgenerator}, \emph{Startseite} und \emph{NeuesRezept}. Dieser Footer der GUI wurde in jeder Klasse implementiert, in der er angezeigt wird und lediglich der Hauptinhalt wird ausgetauscht. Das führt zu einer Dopplung der Informationen. Würden die Entwickler entscheiden beispielsweise den Footer der GUIs ändern zu wollen und beispielsweise den Button Text \enquote{Startseite} durch \enquote{HomePage} ersetzen zu wollen, müsste diese kleine Änderung in drei Klassen geändert werden. Diese Verletzung des DRY-Prinzips wurde begangen, weil die Seite ohne Designkonzept entwickelt wurde.  

Der \code{EntityManagers} ist ein weiteres Beispiel für die Einhaltung des DRY-Prinzips. Unser \code{EntityManager} dient der Datenhaltung und hat die Aufgaben, Objekte zu speichern/löschen und zu finden. Er wird von allen Objekten benutzt und sorgt somit dafür, dass nicht jedes Objekt diese Methoden implementieren muss, wodurch Redundanz vermieden wurde.

