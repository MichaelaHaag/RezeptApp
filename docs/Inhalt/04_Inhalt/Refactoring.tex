\chapter{Refactoring}
Refaktorisierung (auch als Refactoring bezeichnet) ist ein Prozess in der Softwareentwicklung, bei dem der Code einer Anwendung geändert wird, ohne das Verhalten der Anwendung selbst zu ändern. Das Ziel von Refaktorisierung ist es, den Code zu verbessern, indem er einfacher, verständlicher und wartbarer gemacht wird.

Während der Entwicklung von Software kann es vorkommen, dass der Code mit der Zeit unübersichtlich und komplex wird. Dies kann dazu führen, dass Änderungen oder Erweiterungen an der Software schwierig und fehleranfällig sind. Durch Refaktorisierung kann der Code so umstrukturiert werden, dass er einfacher zu verstehen und zu warten ist.
\subsection{Code Smells}
Code Smells sind Indikatoren für potenzielle Probleme im Code bzw. die Bezeichnung für verbesserungswürdige Codestellen, die bei der Refaktorisierung behoben werden können. 
\subsubsection{Duplicated Code}
Duplicated Code ist ein Code-Smell, bei dem derselbe Code an mehreren Stellen im Programm vorkommt. Das bedeutet, dass eine bestimmte Funktionalität oder Logik mehrmals implementiert wurde, anstatt eine abstrakte Lösung zu entwickeln, die an verschiedenen Stellen im Code wiederverwendet werden kann. In \autoref{DRY} wurden die Stellen an denen Code doppelt existiert schon analysiert. Alle GUI's haben denselben Footer. Im Footer befinden sich die drei Buttons: Zufallsgenerator, Startseite und Neues Rezept. Dieser Footer der GUI wurde in jeder Klasse implementiert, in der er angezeigt wird und lediglich der Hauptinhalt wird ausgetauscht. Das führt zu einer Dopplung der Informationen. Wenn der Entwickler beispielsweise den Footer der GUIs ändern möchte und beispielsweise den Button Text Startseite durch HomePage ersetzen zu wollen, müsste diese kleine Änderung in 3 Klassen geändert werden. 
\subsubsection{Long Method}\label{LM}
Der Code Smell Long Method bezieht sich auf eine lange Methode in einem Programm oder einer Codebasis. Eine lange Methode ist eine Methode, die zu viele Aufgaben ausführt und zu lang ist, um sie leicht zu verstehen, zu warten oder zu ändern. 
Die Methode loadCSVDaten der Klasse DataReader ist vergleichsweise lang. Hier werden die Daten Zeilenweise aus den CSV-Dateien gelesen und im EntityManager gespeichert.
Da es fünf verschiedene CSV-Dateien gibt, muss für jede CSV-Datei ein CSVReader erstellt, die Dateien in eine List gelesen und anschließend jede Zeile auseinander genommen werden. Diese Methode ist aufgrund dessen unlesbar und unübersichtlich. Besser wäre es, dass aufsplitten der einzelnen Zeilen der CSV für jedes Objekt auszulagern. Es wäre sogar denkbar, das Laden der einzelnen CSV-Dateien in eigene Methoden zu packen, um die Funktionalität zu kapseln.
\subsubsection{Large Class}
Der Code Smell Large Class bezieht sich auf eine Klasse in einem Programm, das zu viele Aufgaben hat und zu groß ist, um leicht zu verstehen, zu warten oder zu ändern. Eine große Klasse kann schwer zu lesen und zu verstehen sein, da sie viele Details enthält und nicht in kleinere, leichter zu verstehende Teile aufgeteilt ist. Große Klassen können auch schwer zu warten oder zu ändern sein, da Änderungen an einer großen Klasse Auswirkungen auf viele Teile des Codes haben können. Die Klasse RezeptBearbeiten hat eine stark erhöhte Zeilenanzahl im Vergleich zu anderen Klassen des Projektes. In dieser Klasse wird das Java Swing Frontend implementiert, dass angezeigt wird, wenn ein Benutzer ein vorhandenes Rezept bearbeiten möchte. Hier ist das
Single Responsibility Principle verletzt, da die Klasse sowohl das Anzeigen der einzelnen Komponenten implementiert, als auch die Funktionalitäten der einzelnen Buttons. Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Ein weiterer Code Smell: Large Class ist die Klasse DataReader. Auch diese Klasse ist verhältnismäßig groß. In dieser Klasse wird die Funktionalitäten zum Laden und Speichern der Daten aus den CSV-Dateien implementiert. Hier ist auch das Single Responsibility Principle verletzt, da die Klasse sowohl das Laden und Speichern der Daten implementiert, aber auch das Erstellen der Objekte aus den geladenen Daten Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Auch dieser Code Smell sollte behoben werden, indem die Funktionalität in eine weitere Klasse ausgelagert wird.
\subsection{Refactoring}
\subsubsection{Extract Method}
Wie in \autoref{LM} beschrieben, ist die Methode loadCSVDaten sehr lang. Aus diesem Grund wurde hier das Refactoring Extract Method angewendet und somit das aufsplitten der einzelnen Zeilen der CSV für jedes Objekt in eine eigene Methode ausgelagert.
Durch die Auslagerung der Funktionalität wurde der Umfang der Methode reduziert und sie ist übersichtlicher geworden. 
\todo{Ist der Satz so richtig?}
Weiterer Vorteil der Auslagerung ist das die Tests auf die Methode nun einfacher angewendet werden können. 
Dieses Refactoring kann im Commit d3ace6a eingesehen werden.
\subsubsection{Rename Method}
Das Refactoring Rename Methode musste für unser Projekt nicht angewendet werden, da wir direkt mit den Änderungen der Ubiquitous Language alle Methode, Klassen und Objekte in Deutsch und der Domäne entsprechend gewählt haben. Daher haben wir alle Klassen und Methoden Namen so gewählt, dass direkt deutlich wird, was diese Methode macht und wofür eine Klasse zuständig ist.
\subsubsection{Replace Temp with Query}
Das Refactoring Replace Temp with Query zielt darauf ab, die Verwendung von Zwischenvariablen (Temporärvariablen) in Code-Blöcken zu reduzieren oder zu eliminieren, indem sie durch Abfrageausdrücke ersetzt werden. 
Laut Vorlesung sollen temporäre (lokale) Variablen, die zum Zwischenspeichern des Ergebnis einer Berechnung verwendet werden vermieden werden. Die Berechnungen sollen in einzelne Variablen ausgelagert werden und anschließend sollen Methoden anstatt Variablen gelesen werden. 
Da in unserer Anwendung keine Berechnungen im eigentlichen Sinne betrieben werden, wurden weitere Recherchen zu dem Thema Replace Temp with Query betrieben. Auch Martin Fowler hat das Thema Replace Temp with Query in seinem Buch \glqq Improving the Design of Existing Code \grqq{} beschrieben. So heißt es, dass das Problem mit Temps ist, dass sie temporär und lokal sind. Da sie können nur im Kontext der Methode gesehen werden, in der sie sich befinden verwendet, tendieren Temps dazu, längere Methoden zu fördern.
Durch das ersetzten der Temps durch Methoden aufrufe, kann jede Methode in der Klasse auf die Informationen zugreifen. Das hilft
viel dabei, saubereren Code für die Klasse zu entwickeln.
Daher haben wir das Refaktoring auf die Methode zufälligesRezeptUUID angewendet. Hierbei wurde keine neue Methode, die die Berechnung durchführt entwickelt, sondern die Anzahl der vorhandenen Temps durch schon vorhandene Methoden zu ersetzen. Der Code-Abschnitt verwendet eine temporäre Variable (zufallsRezept), um ein zufälliges Element aus einer Liste von Rezepten auszuwählen und die UUID dieses Elements zurückzugeben. Stattdessen haben wir die temporäre Variable durch eine direkte Abfrage ersetzt, die die UUID des zufällig ausgewählten Rezepts zurückgibt. Dadurch wurde die Methode übersichtlicher.
Ein weiteres Replace Temp with Query haben wir in der Methode findeRezepteZuKategorie in der Klasse RezeptRepository vorgenommen. Diese Methode sucht alle Rezepte, die zu einer bestimmten Kategorie gehören, und gibt die Daten dieser Rezepte in Form eines String-Arrays zurück. Die Änderungen können in folgendem Commit nachvollzogen werden: 
Der entscheidende Unterschied hier ist, dass die findeAlleRezepte()-Funktion direkt in die Schleife integriert wurde. Das bedeutet, dass die temporäre Variable alleRezepte nicht mehr benötigt wird. Stattdessen wird eine Stream-basierte Abfrage verwendet, um die Kategorien jedes Rezepts abzufragen und zu prüfen, ob die eingabeKategorie darin enthalten ist.
Außerdem wurde die zweite for-Schleife am Ende des ursprünglichen Codes entfernt, die dazu diente, die ausgewähltesRezept-Liste in ein Array umzuwandeln. Stattdessen wurde die toArray()-Methode von ArrayList verwendet, um das Array direkt zu generieren. 
Dadurch wurden in beiden Methoden temporäre Variablen durch Methoden aufrufe ersetzt. Wir haben hier zwar keine neuen Methoden neu erstellt und schon vorhandene Mthoden benutzt allerdings konnte trotzdem das Ziel erreicht werden die Klasse zu kürzen und übersichtlicher zu machen.