\chapter{Refactoring}
Refaktorisierung (auch als Refactoring bezeichnet) ist ein Prozess in der Softwareentwicklung, bei dem der Code einer Anwendung geändert wird, ohne das Verhalten der Anwendung selbst zu ändern. Das Ziel von Refaktorisierung ist es, den Code zu verbessern, indem er einfacher, verständlicher und wartbarer gemacht wird.

Während der Entwicklung von Software kann es vorkommen, dass der Code mit der Zeit unübersichtlich und komplex wird. Dies kann dazu führen, dass Änderungen oder Erweiterungen an der Software schwierig und fehleranfällig sind. Durch Refaktorisierung kann der Code so umstrukturiert werden, dass er einfacher zu verstehen und zu warten ist.
\subsection{Code Smells}
Code Smells sind Indikatoren für potenzielle Probleme im Code bzw. die Bezeichnung für verbesserungswürdige Codestellen, die bei der Refaktorisierung behoben werden können. 
\subsubsection{Duplicated Code}
Duplicated Code ist ein Code-Smell, bei dem derselbe Code an mehreren Stellen im Programm vorkommt. Das bedeutet, dass eine bestimmte Funktionalität oder Logik mehrmals implementiert wurde, anstatt eine abstrakte Lösung zu entwickeln, die an verschiedenen Stellen im Code wiederverwendet werden kann. In \autoref{DRY} wurden die Stellen an denen Code doppelt existiert, bereits analysiert. Alle GUI's haben denselben Footer. Im Footer befinden sich die drei Buttons: \emph{Zufallsgenerator}, \emph{Startseite} und \emph{NeuesRezept}. Dieser Footer der GUI wurde in jeder Klasse implementiert, in der er angezeigt wird und lediglich der Hauptinhalt wird ausgetauscht. Das führt zu einer Dopplung der Informationen. Wenn der Entwickler beispielsweise den Footer der GUI's ändern möchte und beispielsweise den Button Text Startseite durch HomePage ersetzen zu wollen, müsste diese kleine Änderung in drei Klassen geändert werden. 

\subsubsection{Long Method}\label{LM}
Der Code Smell Long Method bezieht sich auf eine lange Methode in einem Programm oder einer Codebasis. Eine lange Methode ist eine Methode, die zu viele Aufgaben ausführt und zu lang ist, um sie leicht zu verstehen, zu warten oder zu ändern. 
Die Methode \code{loadCSVDaten} der Klasse \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/Datenpersistenz/DataReader.java}{\code{DataReader}} ist vergleichsweise lang. Hier werden die Daten zeilenweise aus den CSV-Dateien gelesen und im \code{EntityManager} gespeichert.
Da es fünf verschiedene CSV-Dateien gibt, muss für jede CSV-Datei ein \code{CSVReader}-Objekt erstellt, die Dateien in eine Liste gelesen und anschließend jede Zeile verarbeitet werden. Diese Methode ist aufgrund dessen schlecht lesbar und unübersichtlich. Besser wäre es, die Verarbeitung der einzelnen Zeilen der CSV für jedes Objekt auszulagern. Es wäre sogar denkbar, das Laden der einzelnen CSV-Dateien in eigene Methoden zu packen, um die Funktionalität zu kapseln.

\subsubsection{Large Class}
Der Code Smell Large Class bezieht sich auf eine Klasse, welche zu viele Aufgaben hat und zu groß ist, um leicht zu verständlich oder wartbar zu sein. Eine große Klasse kann schwer zu lesen und zu verstehen sein, da sie viele Details enthält und nicht in kleinere, leichter zu verstehende Teile aufgeteilt ist. Große Klassen können auch schwer zu warten oder zu ändern sein, da Änderungen an einer großen Klasse Auswirkungen auf viele Teile des Codes haben können. Die Klasse \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/0-Plugins/src/main/java/de/rezeptapp/plugins/gui/RezeptBearbeiten.java}{\code{RezeptBearbeiten}} hat eine stark erhöhte Zeilenanzahl im Vergleich zu anderen Klassen des Projektes. In dieser Klasse wird das Java Swing Frontend implementiert, welches angezeigt wird, wenn ein Benutzer ein vorhandenes Rezept bearbeiten möchte. Hier ist auch das Single Responsibility Principle verletzt, da die Klasse sowohl das Anzeigen der einzelnen Komponenten implementiert, als auch die Funktionalitäten der einzelnen Buttons. Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Ein weiterer Code Smell Large Class ist die Klasse \href{https://github.com/MichaelaHaag/RezeptApp/blob/main/1-Adapter/src/main/java/de/rezeptapp/adapter/Datenpersistenz/DataReader.java}{\code{DataReader}}. Auch diese Klasse ist verhältnismäßig groß. In dieser Klasse wird die Funktionalitäten zum Laden und Speichern der Daten aus den CSV-Dateien implementiert. Hier ist auch das Single Responsibility Principle verletzt, da die Klasse sowohl das Laden und Speichern der Daten implementiert, als auch das Erstellen der Objekte aus den geladenen Daten. Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Auch dieser Code Smell sollte behoben werden, indem die Funktionalität in eine weitere Klasse ausgelagert wird.

\subsection{Refactoring}
\subsubsection{Extract Method}
Wie in \autoref{LM} beschrieben, ist die Methode \code{loadCSVDaten} sehr lang. Aus diesem Grund wurde hier das Refactoring Extract Method angewendet und somit die Verarbeitung der einzelnen Zeilen der CSV für jedes Objekt in eine eigene Methode ausgelagert.
Durch die Auslagerung der Funktionalität wurde der Umfang der Methode reduziert und sie ist übersichtlicher geworden. 
Weiterer Vorteil der Auslagerung ist, dass die Tests auf die Methode nun einfacher angewendet werden können. 
Dieses Refactoring kann im Commit \href{https://github.com/MichaelaHaag/RezeptApp/commit/d3ace6a38e46831cee35d0b270c41c4fd5783162}{\code{d3ace6a}} eingesehen werden.

\subsubsection{Rename Method}
Das Refactoring Rename Methode musste für unser Projekt nicht angewendet werden, da wir direkt mit den Änderungen der Ubiquitous Language alle Methoden-, Klassen- und Objektnamen in Deutsch und der Domäne entsprechend gewählt haben. Daher haben wir alle Klassen und Methoden Namen so gewählt, dass direkt deutlich wird, was diese Methode macht und wofür eine Klasse zuständig ist.

\subsubsection{Replace Temp with Query}
Das Refactoring Replace Temp with Query zielt darauf ab, die Verwendung von Zwischenvariablen (Temporärvariablen) in Code-Blöcken zu reduzieren oder zu eliminieren, indem sie durch Abfrageausdrücke ersetzt werden. 
Laut Vorlesung sollen temporäre (lokale) Variablen, die zum Zwischenspeichern des Ergebnisses einer Berechnung verwendet werden, vermieden werden. Die Berechnungen sollen in einzelne Variablen ausgelagert werden und anschließend sollen Methoden anstatt Variablen gelesen werden. 
Da in unserer Anwendung keine Berechnungen im eigentlichen Sinne betrieben werden, wurden weitere Recherchen zu dem Thema Replace Temp with Query betrieben. Auch Martin Fowler hat das Thema Replace Temp with Query in seinem Buch \enquote{Improving the Design of Existing Code} beschrieben \footnote[1]{Fowler, Martin: Improving the Design of Existing Code, Addison-Wesley Professional, 1999, S.120 ff.}. So heißt es, dass das Problem mit Temps ist, dass sie temporär und lokal sind. Da sie nur im Kontext der Methode gesehen werden können, in der sie sich befinden, tendieren Temps dazu, längere Methoden zu fördern. Durch das ersetzten der Temps durch Methodenaufrufe, kann jede Methode in der Klasse auf die Informationen zugreifen. Das hilft viel dabei, saubereren Code für die Klasse zu entwickeln.

Daher haben wir das Refactoring auf die Methode \code{zufälligeRezeptUUID} angewendet. Hierbei wurde keine neue Methode, die die Berechnung durchführt,entwickelt, sondern die Anzahl der vorhandenen Temps durch schon vorhandene Methoden ersetzt. Der Code-Abschnitt verwendet eine temporäre Variable (zufallsRezept), um ein zufälliges Element aus einer Liste von Rezepten auszuwählen und die UUID dieses Elements zurückzugeben. Stattdessen haben wir die temporäre Variable durch eine direkte Abfrage ersetzt, die die UUID des zufällig ausgewählten Rezepts zurückgibt. Dadurch wurde die Methode übersichtlicher. Die Refaktorisierung können in dem Commit \href{https://github.com/MichaelaHaag/RezeptApp/commit/4e0bedc859ba644d448fe4c89a3a6e1320519593}{\code{4e0bedc}} eingesehen werden. 

Ein weiteres Temp Refactoring haben wir in der Methode \code{findeRezepteZuKategorie} in der Klasse \code{RezeptRepository} vorgenommen. Diese Methode sucht alle Rezepte, die zu einer bestimmten Kategorie gehören und gibt die Daten dieser Rezepte in Form eines String-Arrays zurück. Der entscheidende Unterschied hier ist, dass die \code{findeAlleRezepte()}-Funktion direkt in die Schleife integriert wurde. Das bedeutet, dass die temporäre Variable \code{alleRezepte} nicht mehr benötigt wird. Stattdessen wird eine Stream-basierte Abfrage verwendet, um die Kategorien jedes Rezepts abzufragen und zu prüfen, ob die \code{eingabeKategorie} darin enthalten ist.
Außerdem wurde die dritte for-Schleife am Ende des ursprünglichen Codes entfernt, die dazu diente, die \code{ausgewähltesRezept}-Liste in ein Array umzuwandeln. Stattdessen wurde die toArray()-Methode von ArrayList verwendet, um das Array direkt zu generieren. 
Dadurch wurden in beiden Methoden temporäre Variablen durch Methodenaufrufe ersetzt. Wir haben hier zwar keine neuen Methoden neu erstellt und schon vorhandene Methoden benutzt, allerdings konnte trotzdem das Ziel erreicht werden, die Klasse zu kürzen und übersichtlicher zu machen. Die gemachten Änderungen können im Commit \href{https://github.com/MichaelaHaag/RezeptApp/commit/4e0bedc859ba644d448fe4c89a3a6e1320519593}{\code{4e0bedc}} eingesehen werden. 

\todo{Abschlusssatz?}