\chapter{Refactoring}
Refaktorisierung (auch als Refactoring bezeichnet) ist ein Prozess in der Softwareentwicklung, bei dem der Code einer Anwendung geändert wird, ohne das Verhalten der Anwendung selbst zu ändern. Das Ziel von Refaktorisierung ist es, den Code zu verbessern, indem er einfacher, verständlicher und wartbarer gemacht wird.

Während der Entwicklung von Software kann es vorkommen, dass der Code mit der Zeit unübersichtlich und komplex wird. Dies kann dazu führen, dass Änderungen oder Erweiterungen an der Software schwierig und fehleranfällig sind. Durch Refaktorisierung kann der Code so umstrukturiert werden, dass er einfacher zu verstehen und zu warten ist.
\subsection{Code Smells}
Code Smells sind Indikatoren für potenzielle Probleme im Code bzw. die Bezeichnung für verbesserungswürdige Codestellen, die bei der Refaktorisierung behoben werden können. 
\subsubsection{Duplicated Code}
Duplicated Code ist ein Code-Smell, bei dem derselbe Code an mehreren Stellen im Programm vorkommt. Das bedeutet, dass eine bestimmte Funktionalität oder Logik mehrmals implementiert wurde, anstatt eine abstrakte Lösung zu entwickeln, die an verschiedenen Stellen im Code wiederverwendet werden kann. In \autoref{DRY} wurden die Stellen an denen Code doppelt existiert schon analysiert. Alle GUI's haben denselben Footer. Im Footer befinden sich die drei Buttons: Zufallsgenerator, Startseite und Neues Rezept. Dieser Footer der GUI wurde in jeder Klasse implementiert, in der er angezeigt wird und lediglich der Hauptinhalt wird ausgetauscht. Das führt zu einer Dopplung der Informationen. Wenn der Entwickler beispielsweise den Footer der GUIs ändern möchte und beispielsweise den Button Text Startseite durch HomePage ersetzen zu wollen, müsste diese kleine Änderung in 3 Klassen geändert werden. 
\subsubsection{Long Method}
Der Code Smell Long Method bezieht sich auf eine lange Methode in einem Programm oder einer Codebasis. Eine lange Methode ist eine Methode, die zu viele Aufgaben ausführt und zu lang ist, um sie leicht zu verstehen, zu warten oder zu ändern. 
Die Methode loadCSVDaten der Klasse DataReader ist vergleichsweise lang. Hier werden die Daten Zeilenweise aus den CSV Dateien gelesen und im EntityManager gespeichert.
Da es fünf verschiedene CSV Dateien gibt, muss für jede CSV Datei ein CSVReader erstellt, die Dateien in eine List gelesen und anschließend jede Zeile auseinander genommen werden. Diese Methode ist aufgrund dessen unlesbar und unübersichtlich. Besser wäre es, dass aufsplitten der einzelnen Zeilen der CSV für jedes Objekt auszulagern. Es wäre sogar denkbar, das Laden der einzelnen CSV Dateien in eigene Methoden zu packen, um die Funktionalität zu kapseln.
\subsubsection{Large Class}
Der Code Smell Large Class bezieht sich auf eine Klasse in einem Programm, das zu viele Aufgaben hat und zu groß ist, um leicht zu verstehen, zu warten oder zu ändern. Eine große Klasse kann schwer zu lesen und zu verstehen sein, da sie viele Details enthält und nicht in kleinere, leichter zu verstehende Teile aufgeteilt ist. Große Klassen können auch schwer zu warten oder zu ändern sein, da Änderungen an einer großen Klasse Auswirkungen auf viele Teile des Codes haben können. Die Klasse RezeptBearbeiten hat eine stark erhöhte Zeilenanzahl im Vergleich zu anderen Klassen des Projektes. In dieser Klasse wird das Java Swing Frontend implementiert, dass angezeigt wird, wenn ein Benutzer ein vorhandenes Rezept bearbeiten möchte. Hier ist das
Single Responsibility Principle verletzt, da die Klasse sowohl das Anzeigen der einzelnen Komponenten implemntiert, als auch die Funktionalitäten der einzelnen Buttons. Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Ein weiterer Code Smell: Large Class ist die Klasse DataReader. Auch diese Klasse ist verhältnismäßig groß. In dieser Klasse wird die Funktionalitäten zum Laden und Speichern der Daten aus den CSV Dateien implementiert. Hier ist auch das Single Responsibility Principle verletzt, da die Klasse sowohl das Laden und Speichern der Daten implementiert, aber auch das Erstellen der Objekte aus den geladenen Daten Aufgrund dieser Verletzung des Single Responsibility Principles und der großen Menge an Code ist die Klasse sehr unübersichtlich. Auch dieser Code Smell sollte behoben werden, indem die Funktionalität in eine weitere Klasse ausgelagert wird.
